// Version 45.0 - Expert Web Audio Engine
// English Only Code as requested

const version = "v45.0";

let audioCtx;
let bgSource, maskSource;
let bgGain, maskGain;
let analyser, dataArray;
const THRESHOLD = 30;

async function initSystem() {
    try {
        // 1. Create Audio Context
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // 2. Load Audio Files as ArrayBuffers
        const [bgBuffer, maskBuffer] = await Promise.all([
            fetch('music.mp3').then(r => r.arrayBuffer()).then(b => audioCtx.decodeAudioData(b)),
            fetch('noise.mp3').then(r => r.arrayBuffer()).then(b => audioCtx.decodeAudioData(b))
        ]);

        // 3. Setup Mic Stream
        const devices = await navigator.mediaDevices.enumerateDevices();
        const extMic = devices.find(d => d.kind === 'audioinput' && (d.label.toLowerCase().includes('dock') || d.label.toLowerCase().includes('external')));
        
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: { deviceId: extMic ? { exact: extMic.deviceId } : undefined,
                     echoCancellation: false, noiseSuppression: false }
        });

        // 4. Setup Nodes
        analyser = audioCtx.createAnalyser();
        const micSource = audioCtx.createMediaStreamSource(stream);
        micSource.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        // 5. Setup Music & Noise Sources
        bgSource = audioCtx.createBufferSource();
        bgSource.buffer = bgBuffer;
        bgSource.loop = true;
        bgGain = audioCtx.createGain();
        bgGain.gain.value = 0.5;
        bgSource.connect(bgGain).connect(audioCtx.destination);

        maskSource = audioCtx.createBufferSource();
        maskSource.buffer = maskBuffer;
        maskSource.loop = true;
        maskGain = audioCtx.createGain();
        maskGain.gain.value = 0.0; // Start silent
        maskSource.connect(maskGain).connect(audioCtx.destination);

        // Start playing both (Inaudible noise)
        bgSource.start(0);
        maskSource.start(0);

        update();
        document.getElementById('startBtn').style.display = 'none';
        document.getElementById('mic-name').innerText = "MIC: " + (extMic ? extMic.label : "INTERNAL");
    } catch (e) {
        alert("Init Error: " + e.message);
    }
}

function update() {
    requestAnimationFrame(update);
    analyser.getByteFrequencyData(dataArray);
    let avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
    document.getElementById('volNum').innerText = Math.round(avg);

    if (avg >= THRESHOLD) {
        maskGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 0.1);
        bgGain.gain.setTargetAtTime(0.9, audioCtx.currentTime, 0.1);
        document.body.classList.add('alert-mode');
    } else {
        maskGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.1);
        bgGain.gain.setTargetAtTime(0.5, audioCtx.currentTime, 0.1);
        document.body.classList.remove('alert-mode');
    }
}
