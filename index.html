import javax.sound.sampled.*;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Version: v54.4
 * Project: Clinical Audio Guard (Java Edition)
 * Core logic for real-time mic sensing and master volume control.
 */
public class AudioVolumeService implements Runnable {

    private static final float THRESHOLD = 0.05f; 
    private static final int BASE_VOL = 50;
    private static final int MAX_VOL = 75;
    
    private boolean isBoosted = false;
    private long noiseStartTime = 0;
    private boolean running = true;

    @Override
    public void run() {
        startMonitoring();
    }

    public void startMonitoring() {
        // 1. Setup Audio Format
        AudioFormat format = new AudioFormat(44100, 16, 1, true, false);
        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);

        if (!AudioSystem.isLineSupported(info)) {
            System.err.println("Line not supported. Check microphone connection.");
            return;
        }

        try (TargetDataLine line = (TargetDataLine) AudioSystem.getLine(info)) {
            line.open(format);
            line.start();

            System.out.println("Bolton Project: Monitoring started at Base Volume 50...");
            setSystemVolume(BASE_VOL);

            byte[] buffer = new byte[1024];
            
            while (running) {
                int bytesRead = line.read(buffer, 0, buffer.length);
                if (bytesRead > 0) {
                    float currentRms = calculateRMS(buffer, bytesRead);

                    if (currentRms > THRESHOLD) {
                        if (noiseStartTime == 0) noiseStartTime = System.currentTimeMillis();
                        
                        long elapsed = System.currentTimeMillis() - noiseStartTime;
                        if (!isBoosted && elapsed >= 3000) { // 3 sec sustained noise
                            System.out.println("Noise detected! Fading UP to 75%...");
                            fadeVolume(BASE_VOL, MAX_VOL, 5000); // 5 sec fade
                            isBoosted = true;
                        }
                    } else {
                        if (isBoosted) {
                            System.out.println("Noise cleared. Fading DOWN to 50%...");
                            fadeVolume(MAX_VOL, BASE_VOL, 3000); // 3 sec fade
                            isBoosted = false;
                        }
                        noiseStartTime = 0;
                    }
                }
            }
        } catch (LineUnavailableException e) {
            e.printStackTrace();
        }
    }

    private float calculateRMS(byte[] audioData, int bytesRead) {
        long sum = 0;
        short[] samples = new short[bytesRead / 2];
        ByteBuffer.wrap(audioData).order(ByteOrder.LITTLE_ENDIAN).asShortBuffer().get(samples);
        
        for (short sample : samples) {
            sum += sample * sample;
        }
        
        double lrms = Math.sqrt(sum / (double)samples.length);
        return (float) (lrms / 32768.0); // Normalize to 0.0 ~ 1.0
    }

    private void fadeVolume(int start, int end, int durationMs) {
        int steps = 25; // More steps for smoother transition
        int interval = durationMs / steps;
        float stepSize = (float) (end - start) / steps;

        for (int i = 1; i <= steps; i++) {
            int target = (int) (start + (stepSize * i));
            setSystemVolume(target);
            try { Thread.sleep(interval); } catch (InterruptedException e) {}
        }
    }

    private void setSystemVolume(int volume) {
        try {
            // NirCmd uses a scale of 0 to 65535 for setsysvolume
            int nirVolume = (int) (65535.0 * volume / 100.0);
            String command = "nircmd.exe setsysvolume " + nirVolume;
            Runtime.getRuntime().exec(command);
        } catch (IOException e) {
            System.err.println("NirCmd error: Ensure nircmd.exe is in the project path.");
        }
    }

    public void stop() {
        this.running = false;
    }
}
